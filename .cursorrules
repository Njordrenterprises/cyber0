# Card-Based Architecture System Rules

## Card Module Structure

Every card MUST follow this exact structure:

### 1. Server-Side Card Class

```typescript
// src/cards/[card-name]/[card-name].ts
import { Card, CardState, CardKvEntry } from '../cards.ts';
import type { CardMessage } from '../../../db/client/types.ts';

export interface [CardName]State extends CardState {
  // Card-specific state
}

export interface [CardName]KvEntry extends CardKvEntry {
  // Card-specific KV entry data
}

class [CardName]Card extends Card<[CardName]State, [CardName]KvEntry> {
  // Required overrides
  protected override async loadInitialState(): Promise<void> {
    const entry = await this.getKvEntry();
    if (entry) {
      // Initialize card state from KV
    }
  }

  override getState(): [CardName]State {
    return {
      ...super.getState(),
      // Return card-specific state
    };
  }

  protected override getKvKey(): Deno.KvKey {
    return ['cards', this.id, this.userId];
  }

  // Alpine.js methods
  getAlpineMethods() {
    return {
      // Expose methods for client-side use
    };
  }
}

const [cardName]Card = new [CardName]Card('[card-name]');
export default [cardName]Card;
```

### 2. Client-Side Methods

```typescript
// db/client/[card-name].ts
import type { [CardName]Methods } from './types.ts';
import { getCardData } from './types.ts';

export function get[CardName]Methods(): [CardName]Methods {
  return {
    kv: {
      get: async <T>(key: unknown[]) => {
        const response = await fetch(`/kv/get?key=${key.join(',')}`);
        return await response.json() as T | null;
      },
      set: async (key: unknown[], value: unknown) => {
        await fetch('/kv/set', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key: key.join(','), value })
        });
      }
    },
    // Card-specific client methods that use getCardData() for cross-platform access
  };
}

export function get[CardName]Script(): string {
  return `
    globalThis.cardData = globalThis.cardData || {};
    globalThis.cardData.[cardName] = globalThis.cardData.[cardName] || ${JSON.stringify(get[CardName]Methods())};
  `;
}
```

### 3. HTML Template

```html
<!-- src/cards/[card-name]/[card-name].html -->
<div
  class="card [card-name]-card"
  x-data="{ 
       cardData: window.cardData.[cardName],
       async init() {
         // Initialize card data
       }
     }"
  x-init="init"
>
  <!-- Card template -->
</div>
```

### 4. CSS Styles

```css
/* src/cards/[card-name]/[card-name].css */
.[card-name]-card {
  /* Card-specific styles */
}
```

## Cross-Platform Data Access

1. Types:

```typescript
declare global {
  interface Window extends Record<string, unknown> {
    cardData: CardData;
  }
  var cardData: CardData;
}
```

2. Access Helper:

```typescript
export const getCardData = (): CardData => {
  if (typeof window !== "undefined") {
    return (window as Window).cardData;
  }
  return globalThis.cardData;
};
```

## Initialization Rules

1. Server-Side:
   - Card class MUST extend base `Card`
   - MUST implement required overrides
   - MUST export singleton instance

2. Client-Side:
   - MUST use Alpine.js for state management
   - MUST use `window.cardData.[cardName]` in templates
   - MUST use `getCardData()` in TypeScript code
   - MUST handle cleanup in destroy()

3. Styling:
   - MUST use scoped class names
   - MUST follow shared style variables
   - MUST be responsive

## Data Flow Rules

1. KV Operations:
   - Use standard KV endpoints
   - Follow key structure: ['cards', cardId, userId]
   - Handle errors gracefully
   - Always use getCardData() for access

2. State Management:
   - Server maintains source of truth
   - Client syncs via KV operations
   - Use EventSource for real-time updates

## API Standards

1. Client Methods:
   - MUST be async
   - MUST use shared types
   - MUST handle errors
   - MUST use getCardData() for access

2. Server Methods:
   - MUST be bound in getAlpineMethods()
   - MUST maintain type safety
   - MUST validate input

## Best Practices

1. Type Safety:
   - Use TypeScript interfaces
   - Extend base types
   - Validate all data
   - Use proper Window/globalThis types

2. Error Handling:
   - Graceful degradation
   - User feedback
   - Console logging
   - Handle both browser and Deno contexts

3. Performance:
   - Minimize KV operations
   - Batch updates when possible
   - Clean up resources
   - Cache cardData access when appropriate
